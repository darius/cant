(import (use "registers") register-number)
(import (use "parse") the-specs setup-spec-table)
(import (use "walk") walk-code walk-exp unit bind swapping eating)

(to (main _)
  (setup-spec-table)
  (generate-py-assembler "asm.py"))

(to (generate-py-assembler filename)
  (with-output-file py-write-assembler filename))

(to (say-to sink @arguments)
  (for each! ((x arguments))
    (sink .display x))
  (sink .display "\n"))

(to (copy-file source sink)
  (sink .display source.read-all))

(to (py-write-assembler sink)
  (say-to sink "# Generated by Miasma")
  (say-to sink)
  (for with-input-file ((source "examples/miasma/python/x86_stub.py"))
    (copy-file source sink))
  (say-to sink)
  (say-to sink (py-enum (sort register-number.items)))
  (say-to sink)
  (for each! ((mnemonic (sort the-specs.keys)))
    (let spec (the-specs mnemonic))
    (say-to sink (py-gen mnemonic spec.params))))


;; Code translation

(to (py-gen mnemonic code-list)
  (let vars (py-make-variable-list (sum-by py-variable-count code-list)))
  (py-stmt-macro (py-insn-name mnemonic)
                 vars
                 (py-body vars code-list)))

(to (py-make-variable-list n)
  (for each ((k (1 .thru n)))
    ("v~w" .format k)))

(to (py-body vars code-list)
  (begin walking ((code-list code-list) (stmts '()) (vars vars))
    (may code-list
      (be `()
        stmts)
      (be `(,first ,@rest)
        ((walk-code first py-code py-exp)
         vars
         (on (vars2 cv) 
           (walking rest `(,cv ,@stmts) vars2)))))))

;; TODO walker objects instead, with code/exp methods?

(to (py-code code)
  (may code
    (be {bytes signed? count exp}
      (for bind ((cv exp))
        (unit 
         (py-exp-stmt (py-call ("push_~d~w"
                                .format (if signed? "i" "u") (* 8 count))
                               cv)))))
    (be {swap-args code}
      (swapping code))
    (be {mod-r/m e1 e2}
      (for bind ((cv1 e1))
        (for bind ((cv2 e2))
          (unit (py-exp-stmt (py-call "mod_rm" cv1 cv2))))))))

(to (py-exp exp)
  (may exp
    (be {literal n}
      (unit (py-int-literal n)))
    (be {op operator e1 e2}
      (for bind ((cv1 e1))
        (for bind ((cv2 e2))
          (unit (py-binop operator.string cv1 cv2)))))
    (be {hereafter}
      (unit "hereafter"))
    (be {arg @_}
      (eating unit))))


;; Variables

(to (py-variable-count code)

  (to (py-code code)
    (may code
      (be {bytes _ _ exp}
        exp)
      (be {swap-args code}
        code)
      (be {mod-r/m e1 e2}
        (for bind ((cv1 e1))
          (for bind ((cv2 e2))
            (unit (+ cv1 cv2)))))))

  (to (py-exp exp)
    (may exp
      (be {literal _}
        (unit 0))
      (be {op operator e1 e2}
        (for bind ((cv1 e1))
          (for bind ((cv2 e2))
            (unit (+ cv1 cv2)))))
      (be {hereafter}
        (unit 0))
      (be {arg @_}
        (unit 1))))

  ((walk-code code py-code py-exp) '_
                                   (on (_ count) count)))


;; Python code constructors

(to (py-enum items)
  ("\n" .join (for each (((~ sym val) items))
                (chain (as-legal-py-identifier sym.string)
                       " = "
                       (py-int-literal val)))))

(to (py-int-literal n)
  (if (count? n)
      ("0x~d" .format (string<-number n 16)) ;TODO ~h format or something
      (string<-number n)))

(to (py-binop operator cv1 cv2)
  ("(~d ~d ~d)" .format cv1 operator cv2))

(to (py-parenthesize cv)
  (chain "(" cv ")"))

(to (py-call fn-cv @args-cv)
  ("~d(~d)" .format fn-cv (", " .join args-cv)))

(to (py-exp-stmt cv)
  cv)

(to (py-stmt-macro name vars stmts)
  ("\n" .join `(,(py-declare name vars) 
                "    global buf"
                "    hereafter = len(buf)"
                ,@(for each ((stmt stmts))
                    (chain "    " stmt)))))

(to (py-declare name vars)
  ("def ~d(~d):" .format name (", " .join vars)))

(to (py-insn-name mnemonic)
  (as-legal-py-identifier mnemonic.string))

;; Return `str`, but munging out any characters that are used in our 
;; mnemonics but aren't legal in Python identifiers.
(to (as-legal-py-identifier str)
  (string<-list (for yeahs ((ch str))
                  (and (not (":%" .find? ch))
                       (hm (if ("-." .find? ch) #\_)
                           (if (= #\? ch) #\c)
                           (else ch))))))
