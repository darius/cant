(import (use "parser") exp-parse)
(import (use "prelude") build-prelude)


;; Interpreter, explicit-control style

(to (interpret e @(optional r))
  (eval (exp-parse e) (or r prelude-env) {halt}))

(to (eval e r k)
  (may e
    (be {const c}   (reply k c))
    (be {var v}     (reply k (lookup r v)))
    (be {lam _ _ _} (reply k {closure e r}))
    (be {app f a _} (eval f r {ev-arg a r k}))
    (be {the-env}   (reply k r))))

(to (reply k0 val)
  (may k0
    (be {ev-arg a r k} (eval a r {call val k}))
    (be {call fv k}    (invoke fv val k))
    (be {cps-sequel f} (f val))
    (be {halt}         val)))

(to (invoke fn arg k)
  (may fn
    (be {closure {lam v e _} r} (eval e {extend v arg r} k))
    (be {primitive p}           (reply k (p arg)))
    (be {cps-function f}        (f arg k))))

;; Environments
;; TODO use Cant settings instead?

(to (lookup r v)
  (may r
    (be {extend v1 val r1}
      (if (= v v1)
          val
          (lookup r1 v)))
    (be {module map}
      (map v))))

(let prelude-env (build-prelude (export out) interpret invoke reply))


;; Main

(to (main args)
  (for each! ((filename args.rest))
    (out .say "\n~d:\n" filename)
    (out .print (run-file filename))))

(to (run-file filename)
  (let es (with-input-file read-all filename))
  (interpret `(do ,@es)))


(export run-file interpret prelude-env)
