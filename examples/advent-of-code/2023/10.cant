;; (Use run.cant to run this.)

(import (use 'queue) empty push extend peek)

(let eg1 "\
.....
.S-7.
.|.|.
.L-J.
.....")

(let eg2 "\
..F7.
.FJ|.
SJ.L7
|F--J
LJ...")

(let input
;  eg1)
;  eg2)
  data-file.read-all)

(surely (input.split-lines .unique? ~.count)) ;; Uniform-length lines

(let (-- neighborhood (list<- N W E S)) ;; list of offsets from a position to its neighbors
  (do [(w ((input .find #\newline) .+1))] ;; width
    (list<- (- w) -1 1 w)))

(let rune-map (map<- (~ #\| (list<- N S))
                     (~ #\- (list<- E W))
                     (~ #\L (list<- N E))
                     (~ #\J (list<- N W))
                     (~ #\7 (list<- S W))
                     (~ #\F (list<- S E))
                     (~ #\S neighborhood))) ;; For our purpose, the start can be treated as connected all ways

(to (arcs<- pos)
  (for yeahs [(offset (rune-map .get (input pos) '()))]
    ;; Slightly tricky guard to stay inside the visible map.
    (and (not= #\newline (input .get (+ pos offset) #\newline))
         (+ pos offset))))

(surely (~.only (keep (be? #\S) input))) ;; Exactly 1 start position
(let start (input .find #\S))
(let infinity 1000000000)

(to (part1)
  (let distances (array<-count input.count #no))
  
  (to (?step frontier)
    (may (peek frontier)
      (be {empty} #no)
      (be {nonempty (~ pos distance) more-frontier}
        (let children (flexarray<-))
        (for each! [(pos (arcs<- pos))]
          (unless (distances pos)
            (distances .set! pos distance)
            (children .push! (~ pos distance.+1))))
        (extend more-frontier children.values))))

  (distances .set! start 0)
  (let starting-frontier (push empty (~ start 1)))
  (let steps (keep-while yeah? (iterating ?step starting-frontier)))
;;  (dump distances)
  
  (max @(yeahs itself distances.values)))

(to (dump distances)
  (for each! [((~ pos rune) input.items)]
    (out .display (or (distances pos) rune)))
  out.newline)

;; I give up: breadth-first-search seems correct, matches AIMA
;; pseudocode, works on examples, the judge says it's wrong.
;; Variations produce the same answers. The queue library has
;; been used plenty; not worth checking for bugs there.
;; The problem input is big. Not motivated to figure this out rn.
