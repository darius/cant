;; (Use run.cant to run this.)

(let eg1 "\
Time:      7  15   30
Distance:  9  40  200")

(let input
;;  eg1)
  data-file.read-all)

(to (part1)
  (let races (transpose (for each [(line input.split-lines)]
                          (each ~.number line.split.rest))))
  (let n-ways-to-beat
    (for each [(race races)]
      (count-ways-to-beat/brute @race)))
  (* @n-ways-to-beat))

;; Your move: choose v, 0 <= v <= t.
;; Your distance v(t - v) must exceed d.
(to (count-ways-to-beat/brute t d)
  (for tally-by [(v (1 .till t))]
    (< d (* v (- t v)))))

(to (part2)
  (let numbers (for each [(line input.split-lines)]
                 (-> (keep ~.digit? line) ~.text ~.number)))
  (count-ways-to-beat/faster @numbers))

(import (use 'polynomials)
  poly<- poly+ poly- poly* derivative find-root)

;; Solve the equation v(t-v)-d = 0 for v, and return the width between the roots.
(to (count-ways-to-beat/faster t d)
  (let vp (poly<- `(1 0)))
  (let tp (poly<- `(,t)))
  (let dp (poly<- `(,d)))
  (let excessp (poly- (poly* vp (poly- tp vp))
                      dp))
  (let peak (find-root (derivative excessp) 0.0)) ;; 0 is the starting guess
  ;; Starting from both sides of the peak should yield the two different roots:
  (let roots (each ||(find-root excessp it) (list<- peak.-1 peak.+1)))
  (let `(,lo ,hi) roots)
  ((lo.ceiling.exact .thru hi.floor.exact) .count))
