(to (intcode-run core pc)
  (begin ((pc pc))
    (may (step core pc)
      (be #no)
      (be new-pc (loop new-pc)))))

;; TODO take in some virtualization of input and output
(to (step core pc)

  (to (P mode i)
    (may mode
      (be 0 (core (core (+ pc i))))
      (be 1 (core (+ pc i)))))
  
  (to (Addr mode i)
    (may mode
      (be 0 (core (+ pc i)))))
  
  (let (list<- opcode a-mode b-mode c-mode)
    ((core pc) .digits '(100 10 10) 4)) ;TODO this is *really* slow

  ;;(show core pc)
  (may opcode
    (be 1 ; add
      (core .set! (Addr c-mode 3) (+ (P a-mode 1) (P b-mode 2)))
      (+ pc 4))
    (be 2 ; mul
      (core .set! (Addr c-mode 3) (* (P a-mode 1) (P b-mode 2)))
      (+ pc 4))
    (be 3 ; input
      (core .set! (Addr c-mode 1) in.read-line.number)
      (+ pc 2))
    (be 4 ; output
      (out .print (P a-mode 1))
      (+ pc 2))
    (be 99 ; halt
      #no)))

(to (show core pc)
  (let (list<- opcode a-mode b-mode c-mode)
    ((core pc) .digits '(100 10 10) 4))
  (let modes [a-mode b-mode c-mode])
  (out .say "~w ~d" pc (op-names opcode))
  (for each! ((i (1 .thru (op-nargs opcode))))
    (out .say " ~d~w" (mode-names (modes i.-)) (core (+ pc i))))
  out.newline)

(let op-names (map<-lists '((1 add) (2 mul) (3 input) (4 output) (99 halt))))
(let op-nargs (map<-lists '((1 3)   (2 3)   (3 1)     (4 1)      (99 0))))
(let mode-names ["^" ""])

(export intcode-run)
