;; (Use run.cant to run this.)

(let input data-file.read-lines)

(let mem-lhs (like "'mem[' :count ']'"))
(to (parse line)
  (let `(,L ,R) (line .split " = "))
  (may L
    (be "mask" {mask R})
    (else
      (let `(,addr) (mem-lhs L))
      {mem addr R.number})))

(let program (each parse input))

(to (part1)
  (sum-run part1-do-mem))

(to (part2)
  (sum-run part2-do-mem))

(to (sum-run do-mem)
  (let memory (!map<-))
  (run memory do-mem)
  (sum memory.values))

(to (run memory do-mem)
  (let cur-mask (box<- #no))
  (for each! ((insn program))
    (may insn
      (be {mask m}
        (cur-mask .^= m))
      (be {mem addr number}
        (each! (~ memory) (do-mem cur-mask.^ addr number))))))

(to (part1-do-mem mask addr number)
  (list<- (~ .set! addr (enmask-number mask number))))

;; I tried to do this with bitwise AND/OR, but accidentally used
;; 32-bit-only ops. So here we do it on text.
(to (enmask-number mask n)
  (number<-text (enmask mask ("~036b" .format n))
                2))

(to (enmask mask bits)
  (~.text (for each ((m mask) (b bits))
            (may m
              (be #\X b)
              (else   m)))))

(to (part2-do-mem mask addr number)
  (for each ((a (enmask2-many mask addr)))
    (~ .set! a number)))

(to (enmask2-many mask addr)
  (let bit-values
    (for each ((m mask) (rune ("~036b" .format addr)))
      (may m
        (be #\0 `(,rune))
        (be #\1 '(#\1))
        (be #\X '(#\0 #\1)))))
  (for each ((bits (grid* @bit-values)))
    (number<-text bits.text 2)))
