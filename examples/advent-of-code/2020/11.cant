;; (Use run.cant to run this.)

(let inputs data-file.read-lines)

(let nrows inputs.count)
(let ncols ((inputs 0) .count))

(let neighborhood (for those ((d (grid* '(-1 0 1) '(-1 0 1))))
                    (not= d '(0 0))))
(to (neighbors `(,x ,y))
  (for each ((`(,dx ,dy) neighborhood))
    `(,(+ x dx) ,(+ y dy))))

(to (set<-lines lines desired-rune)
  (~.range (for gather (((~ row line) lines.items))
             (for yeahs (((~ col rune) line.items))
               (and (= rune desired-rune)
                    `(,col ,row))))))

(let grid0 (~ (set<-lines inputs #\L)
              (set<-lines inputs #\#)))

(to (show (~ e o))
  (for each! ((y nrows.till))
    (for each! ((x ncols.till))
      (let p `(,x ,y))
      (out .display (if (e .maps? p) #\L (if (o .maps? p) #\# #\.))))
    out.newline)
  out.newline)

(to (same? (~ e1 o1) (~ e2 o2))
  (and (= e1.count e2.count)
       (= o1.count o2.count)
       (for every ((k e1.keys)) (e2 .maps? k))
       (for every ((k o1.keys)) (o2 .maps? k))))

(to (part1)
  (begin stepping ((grid grid0) (n 1))
    (out .say "~w:\n" n)
    (let next (update1 grid))
    (show next)
    (hm (when (same? next grid)
          (let (~ e o) grid)
          o.count)
        (else (stepping next n.+)))))

(to (update1 (~ empties occupied))
  (let n-neighbors (bag<- (gather neighbors occupied.keys)))
  (let new-empties (set<-))
  (let new-occupied (set<-))
  (for each! ((p occupied.keys))
    ((if (<= 4 (n-neighbors p)) new-empties new-occupied)
     .add! p))
  (for each! ((p empties.keys))
    ((if (= 0 (n-neighbors p)) new-occupied new-empties)
     .add! p))
  (~ new-empties new-occupied))

(to (part2)
    (out .say "0:\n")
    (show grid0)
  (begin stepping ((grid grid0) (n 1))
    (out .say "~w:\n" n)
    (let next (update2 grid))
    (show next)
    (hm (when (same? next grid)
          (let (~ e o) grid)
          o.count)
        (else (stepping next n.+)))))

(to (update2 (~ empties occupied))
  (let n-neighbors (bag<- (gather (neighbors2 empties occupied) occupied.keys)))
  (let new-empties (set<-))
  (let new-occupied (set<-))
  (for each! ((p occupied.keys))
    ((if (<= 5 (n-neighbors p)) new-empties new-occupied)
     .add! p))
  (for each! ((p empties.keys))
    ((if (= 0 (n-neighbors p)) new-occupied new-empties)
     .add! p))
  (~ new-empties new-occupied))

;; Return a list of the seats that can see x,y
(to ((neighbors2 empties occupied) p)
  (for gather ((dp neighborhood))
    (begin stepping ((q (vector+ p dp)) (places '()))
      (hm (if (empties .maps? q) (link q places))
          (if (occupied .maps? q) (link q places))
          (do (let `(,x ,y) q))
          (if (< x 0) places)
          (if (= x ncols) places)
          (if (< y 0) places)
          (if (= y nrows) places)
          (else (stepping (vector+ q dp) (link q places)))))))
