;; (Use run.cant to run this.)

(let input (with-input-file ~.read-lines data-file))
(let parse (like "{:letter+} _ {'+'|'-'} :integer"))
(let inputs (~.array (for each ((line input))
                       (let `(,op ,sign ,n) (parse line))
                       `(,op ,(* n (may sign (be "+" 1) (be "-" -1)))))))

(to (part1)
  (run inputs 100000))

(to (part2)
  (begin budgeting ((n-steps 100))
    (out .say "\nbudgeting ~w\n" n-steps)
    (begin flipping ((pc 0))
      (if (inputs .maps? pc)
          (or (flip n-steps pc)
              (flipping pc.+))
          (budgeting (* 2 n-steps))))))

(to (flip n-steps pc)
  (let code inputs.copy)
  (may (code pc)
    (be `("acc" ,n)
      #no)
    (else
      (may (code pc)
        (be `("nop" ,n) (code .set! pc `("jmp" ,n)))
        (be `("jmp" ,n) (code .set! pc `("nop" ,n))))
      (may (run code n-steps)
        (be {finished acc}
          acc)
        (else #no)))))

(to (run code n-steps)
  (let seen (set<-))
  (let end code.count)
  (begin running ((n-steps n-steps) (pc 0) (acc 0))
    (hm (if (= pc end)       {finished acc})
        (if (= 0 n-steps)    {gave-up})
        (if (seen .maps? pc) {looped acc})
        (do (seen .add! pc))
        (may (code pc)
          (be `("acc" ,n)
            (running n-steps.- pc.+ (+ acc n)))
          (be `("nop" ,n)
            (running n-steps.- pc.+ acc))
          (be `("jmp" ,n)
            (running n-steps.- (+ pc n) acc))))))
