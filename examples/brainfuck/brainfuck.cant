;; https://en.wikipedia.org/wiki/Brainfuck
;; Doing it two ways: interpreter and compiler.
;; The input programs must have balanced brackets.
;; See also http://rosettacode.org/wiki/Execute_Brain****

(to (main args)
  (may args.rest
    (be '() (test-file "examples/brainfuck/hello.bf"))
    (be files (each! test-file files))))

(to (test-file filename)
  (let text (with-input-file ~.read-all filename))
  (bf-interpret text)
  (bf-compile-and-run text))

(to (bf-compile-and-run text)
  (let code (bf-compile text))
;;  (out .print code)
  ((cant .play code full-powered-setting) out-byte in-byte))


;; I/O for either version

(to (out-byte byte) (out .display (char<- byte)))
(to (in-byte)       (may stdin.read-char
                      (be (? eof?) -1)
                      (be ch ch.code)))


;; Interpreter

(to (bf-interpret program)
  (let data (!map<-))                   ; run-time data store
  (let jump (match-brackets program))   ; jump targets
  (begin running ((i 0)                 ; instruction pointer
                  (d 0))                ; data pointer
    (may (program .get i)
      (be #\[ (running (if (= 0 (data .get d 0)) (jump i) i.+)
                       d))
      (be #\] (running (if (= 0 (data .get d 0)) i.+ (jump i))
                       d))
      (be #no 'done)
      (be ch  (running i.+
                       (may ch
                         (be #\< d.-)
                         (be #\> d.+)
                         (else (may ch
                                 (be #\- (data .set! d (- (data .get d 0) 1)))
                                 (be #\+ (data .set! d (+ (data .get d 0) 1)))
                                 (be #\. (out-byte (data .get d 0)))
                                 (be #\, (data .set! d (in-byte)))
                                 (else))
                               d)))))))

(to (match-brackets program)
  (let jump (!map<-))
  (for foldl ((stack '())
              ((~ i ch) program.items))
    (may ch
      (be #\[ (link i stack))
      (be #\] (jump .set! stack.first i.+)
              (jump .set! i stack.first.+)
              stack.rest)
      (else   stack)))
  jump)


;; Compiler
;; One semantic difference from the interpreter:
;; bounded memory (using an array instead of a hashmap).
;; You know, since this compiler is about as short as the interpreter
;; there's not much point to the former's existence...

(to (bf-compile program)
  (let expr-stack
    (for foldl ((stack '(0)) (ch program.values))
      (may ch
        (be #\[ (link 'd stack))
        (be #\] (let (link top next rest) stack)
                (link `(begin looping ((d ,next))
                         (if (= 0 (data d))
                             d
                             (looping ,top)))
                      rest))
        (else (let (link top rest) stack)
              (link (may ch
                      (be #\< `(~.- ,top))
                      (be #\> `(~.+ ,top))
                      (be #\- `(decr ,top))
                      (be #\+ `(incr ,top))
                      (be #\. `(emit ,top))
                      (be #\, `(absorb ,top))
                      (else   top))
                    rest)))))
  (surely (= 1 expr-stack.count))
  `(on (out-byte in-byte) ,@bf-prelude ,@expr-stack))

(let bf-prelude
  '((let data (array<-count 30000 0))
    (to (decr d)   (data .update d ~.-)     d)
    (to (incr d)   (data .update d ~.+)     d)
    (to (emit d)   (out-byte (data d))      d)
    (to (absorb d) (data .set! d (in-byte)) d)))


(export bf-interpret bf-compile bf-compile-and-run main)
