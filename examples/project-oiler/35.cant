;; Circular primes

(import (use 'factoring) list-primes-till prime?)

(to (answer limit)
  (let circulars (those circular? (list-primes-till limit)))
  (out .say "circulars: ~w\n" circulars)
  circulars.count)

(to (circular? p)
  (every prime? (-> p.digits rotations ~.rest (:: (each number<-digits it)))))

(to (number<-digits ds)
  (count<-digits ds 10))

(to (count<-digits digits base)         ;N.B. big-endian. TODO add to stdlib?
  (for foldl ((total 0) (digit digits))
    (+ (* base total) digit)))

(to (rotations xs)
  (surely xs.some?)
  (begin rotating ((pre '()) (post xs))
    (if post.none?
        '()
        (link (chain post (reverse pre))  ;; TODO nicer?
              (rotating (link post.first pre) post.rest)))))

;;(out .print (answer 100))
(out .print (answer 1000000)) ;; 55
