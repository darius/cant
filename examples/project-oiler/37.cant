;; Truncatable primes

(import (use 'factoring) the-primes prime?)

(to (answer n)
;;  (let results (v1-list))
  (let results (v2-list))
  (let prefix ((results .first-n n) .list))
  (out .print prefix)
  (sum prefix))

(to (v1-list)
  (those/lazy doubly-truncatable? the-primes))

(to (doubly-truncatable? p)
  (and (<= 10 p)
       (do (let pt p.text)
           (for every ((n (1 .till pt.count)))
             (and (-> pt (~ .first-n n) ~.number prime?)
                  (-> pt (~ .last-n n) ~.number prime?))))))

;; Faster to grow truncatables separately in each direction, and intersect them.
(to (v2-list)
  (intersect/lazy left-truncatables right-truncatables))

;; Lazification of sset-intersect from sset.cant
(to (intersect/lazy xs ys)
  (hm (if xs.none? '())
      (if ys.none? '())
      (may (xs.first .compare ys.first)
        (be '< (intersect/lazy xs.rest ys))
        (be '= (link/lazy xs.first (: (intersect/lazy xs.rest ys.rest))))
        (be '> (intersect/lazy xs ys.rest)))))

(to (list-truncatables extend)
  (to (grow seeds)
    (those prime? (each (:: (extend @it)) (grid* seeds (1 .thru 9)))))
  (let batches (take-while/lazy ~.some? (iterate grow '(2 3 5 7))))
  ;; (The take-while isn't needed for our final answer, but helpful in
  ;; development so we don't hang once the truncatables run out.)
  (gather/lazy sort batches.rest))

(to (extend-left seed digit)  (count<-digits (link digit seed.digits)))
(to (extend-right seed digit) (+ (* 10 seed) digit))

(let left-truncatables (list-truncatables extend-right))
(let right-truncatables (list-truncatables extend-left))


(out .print (answer 11)) ;; 748317
