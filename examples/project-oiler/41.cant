;; Pandigital prime

(import (use 'factoring) prime?)
(import (use "utils") permuter<-)

(to (answer)
  (for some ((nd (9 .down-thru 1))) ;; n digits
    (and (not (3 .divides? (sum (1 .thru nd)))) ;; Skip 'obvious' multiples of 3
         (find-largest-prime nd))))
  
(to (find-largest-prime nd)
  ;; List permutations of 1..nd in decreasing order; return the first good one.
  ;; TODO we could just use the list.permutations method if it were lazy
  (let perm (permuter<- (nd .down-thru 1)))
  ((~ .get 0) (keep/lazy prime? (each/lazy (compose count<-digits perm) ((nd .!) .till)))))

(out .print (answer)) ;; 7652413
