;; Pandigital prime

(import (use 'factoring) prime?)
;;(import (use "utils") lex-permutation)  TODO
(import (use "utils") detect count<-digits)

(to (answer)
  (for some ((nd (9 .down-thru 1))) ;; n digits
    (let digsum (sum (1 .thru nd)))
    (and (not (3 .divides? digsum)) ;; (Every permutation would be a multiple of 3)
         (find-largest-prime nd))))
  
(to (find-largest-prime nd)
  ;; List permutations of 1..9 in decreasing order; return the first good one.
  (let acceptables (for yeahs/lazy ((i (((nd .!) .-) .down-thru 0)))
                     (let n (count<-digits (lex-permutation nd i)))
                     (out .say "prime? ~w\n" n)
                     (and (prime? n) n)))
  (and acceptables.some? acceptables.first)) ;; TODO variant of detect?

(to (lex-permutation n i)
  (let result (flexarray<-))
  (let digit-supply (flexarray<-list (1 .thru n)))  ;; changed from utils.cant
  (for each! ((pos (i .digits (n .down-thru 1) n)))
    (result .push! (digit-supply .pop! pos)))
  result.values)

(out .print (answer)) ;; 7652413
