;; Pandigital multiples

(import (use "utils") lex-permutation detect)

(to (v1-answer)
  ;; List permutations of 1..9 in decreasing order; return the first good one.
  (detect pandigital-multiple? (for each/lazy ((i (((9 .!) .-) .down-thru 0)))
                                 (my-lex-permutation 9 i))))

;; TODO ugh we've needed this hack twice now
(to (my-lex-permutation nd i)
  ;; +1 to each digit because my permutations are of (1 .thru nd) instead of (0 .till nd)
  (each ~.+ (lex-permutation nd i)))

(to (pandigital-multiple? digits)
  (for some ((i '(1 2 3 4)))
    (let n (count<-digits (digits .from 0 i)))
    (begin checking ((target (* 2 n)) (rest (digits .from i)))
      (or rest.none?
          (and (rest .prefix? (let td target.digits))
               (checking (+ target n) (rest .from td.count)))))))

;; Not so brute-force. This is still slower than it needs to be,
;; since we could early-out by comparing to the current best.
(to (v2-answer)
  (max @(for gather ((ndigits (1 .thru 4)))
          (let perms (-> ((9 .down-thru 1) .permutations ndigits)
                         ;; Sorting because (~ .permutations ndigits) doesn't respect order
                         (:: (sort it {reverse}))))
          (-> (yeahs/lazy ?build-pandigital perms)
              (~ .from 0 1)
              ~.list))))

(to (?build-pandigital base)
  (let n (count<-digits base))
  (begin checking ((k 2) (result base))
    (and (not (result .find? 0))
         result.invertible?
         (may (compare result.count 9)
           (be '> #no)
           (be '= result)
           (be '< (checking k.+ (chain result ((* k n) .digits))))))))

;;(let result (v1-answer))
(let result (v2-answer))
(out .print (count<-digits result)) ;; 932718654
