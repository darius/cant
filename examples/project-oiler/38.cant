;; Pandigital multiples

(import (use "utils") lex-permutation detect)

(to (v1-answer)
  ;; List permutations of 1..9 in descending order; return the first good one.
  (detect pandigital-multiple? (for each/lazy ((i (((9 .!) .-) .down-thru 0)))
                                 (my-lex-permutation 9 i))))

;; TODO ugh we've needed this hack twice now
(to (my-lex-permutation nd i)
  ;; +1 to each digit because my permutations are of (1 .thru nd) instead of (0 .till nd)
  (each ~.+ (lex-permutation nd i)))

(to (pandigital-multiple? digits)
  (for some ((i '(1 2 3 4)))
    (let n (count<-digits (digits .from 0 i)))
    (begin checking ((target (* 2 n)) (rest (digits .from i)))
      (or rest.none?
          (and (rest .prefix? (let td target.digits))
               (checking (+ target n) (rest .from td.count)))))))

;; Not so brute-force. For each possible base-prefix length, find the
;; first base prefix that works, trying prefixes in descending order.
(to (v2-answer)
  (max @(for yeahs ((ndigits (1 .thru 4)))
          (some ?build-pandigital ((9 .down-thru 1) .k-permutations ndigits)))))

(to (?build-pandigital base-digits)
  (let base (count<-digits base-digits))
  (begin building ((i 2) (prefix base-digits))
    (and (not (prefix .find? 0))
         prefix.invertible?
         (may (compare prefix.count 9)
           (be '> #no)
           (be '= prefix)
           (be '< (building i.+ (chain prefix ((* i base) .digits))))))))

;;(let result (v1-answer))
(let result (v2-answer))
(out .print (count<-digits result)) ;; 932718654
