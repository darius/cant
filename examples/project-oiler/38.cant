;; Pandigital multiples

(import (use "utils") lex-permutation detect)

(to (v1-answer)
  ;; List permutations of 1..9 in decreasing order; return the first good one.
  (detect pandigital-multiple? (for each/lazy ((i (((9 .!) .-) .down-thru 0)))
                                 (my-lex-permutation 9 i))))

;; TODO ugh we've needed this hack twice now
(to (my-lex-permutation nd i)
  ;; +1 to each digit because my permutations are of (1 .thru nd) instead of (0 .till nd)
  (each ~.+ (lex-permutation nd i)))

(to (pandigital-multiple? digits)
  (for some ((i '(1 2 3 4)))
    (let n (count<-digits (digits .from 0 i)))
    (begin checking ((target (* 2 n)) (rest (digits .from i)))
      (or rest.none?
          (and (rest .prefix? (let td target.digits))
               (checking (+ target n) (rest .from td.count)))))))

;; Not so brute-force.
;; This is still slower than it needs to be, since we could try digits from 9
;; down-thru 1, and early-out by comparing to the current best.
(to (v2-answer)
  (max @(for gather ((ndigits (1 .thru 4)))
          (yeahs ?build-pandigital ((1 .thru 9) .permutations ndigits)))))

(to (?build-pandigital base)
  (let n (count<-digits base))
  (begin checking ((k 2) (result base))
    (and (not (result .find? 0))
         result.invertible?
         (may (compare result.count 9)
           (be '> #no)
           (be '= result)
           (be '< (checking k.+ (chain result ((* k n) .digits))))))))

;;(let result (v1-answer))
(let result (v2-answer))
(out .print (count<-digits result)) ;; 932718654
