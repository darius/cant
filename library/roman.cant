;; Roman numerals
;; TODO: expose as a parson grammar, too?

(to (number<-roman text)
  (let values (each value<-rune text.uppercase))
  (sum (for each ((value `(0 ,@values)) (next-value `(,@values 0)))
         ;; Each letter goes into the sum either negatively or positively,
         ;; depending on the next letter. E.g. X in "XC" means -10, not 10.
         (-> value (if (< value next-value) - +)))))

(let value<-rune
  (map<-lists '((#\M 1000) (#\D 500) (#\C 100) (#\L 50) (#\X 10) (#\V 5) (#\I 1))))

(to (roman<-number n)
  (surely (< 0 n))
  (text<-list (for foldr ((digit n.digits) (roman '()))
                (chain (each rune*10 roman) (runes<-digit digit)))))

(let runes<-digit
  (array<-list (each ~.values (" I II III IV V VI VII VIII IX" .split " "))))
(let rune*10 (map<-items (zip "IVXLC"
                              "XLCDM")))

(export number<-roman roman<-number)
