;; Pseudo-random number generators
;; TODO: port a better one

;; (random-seed<-) -> seed (From system randomness.)
;; (chaos<- seed) -> chaos
;; (chaos .sample-count n) -> n'

(let D 2147483647)

;; Multiplicative congruential
(to (park-miller-chaos<- seed)
  (surely (< 0 seed))
  (let state (box<- seed))

  (to (next)
    (let (~ _ r) (state.^ .*/mod 16807 D))
    (state .^= r)
    r)

  (make chaos
    ;; TODO not thrilled with these names
    (to (~ .sample-count n)
      ;; XXX surely 0 < n <= D
      ((next) .modulo n))                ;XXX not quite fair sampling
    ;; TODO a trait for the remaining methods
    (to (~ .sample xs)
      (xs (chaos .sample-count xs.count)))
    (to (~ .probability numerator denominator)
      (< (chaos .sample-count denominator) numerator))))

;; TODO (chaos .sample-fraction n d) -> #yes n/d of the time. better name: .probability ?
;; TODO chaos-trait for methods like that. Or stick them into the number types.

(let chaos<- park-miller-chaos<-)
(let chaos (chaos<- 1234567))

(to (random-chaos<- randomness-source<-)
  (chaos<- (random-seed<- randomness-source<-)))

(to (random-seed<- randomness-source<-)
  (for with-closing ((source (randomness-source<-)))
    (begin trying ()
      (let seed (read-u32 source))
      (if (< 0 seed D)
          seed
          (trying)))))

;; Read a 4-byte unsigned int, big-endian.
;; TODO should be in a library
;; TODO use .read-u8 on a *binary* source. Then cult-of-the-bound-variable could use this too.
(to (read-u32 source)
  (for foldl ((n 0) (_ (4 .till)))
    (+ (n .<< 8) source.read-rune.code)))

(export chaos<- chaos random-chaos<- random-seed<-)
