;; Ported from github.com/darius/dole

;; Glossary:
;;   p   coordinate (position between runes in text, or `nowhere`)
;;   dir direction
;;   cs  rune-set

;; A flextext is a mutable, growable/shrinkable sequence of runes.
;; Coordinates denote the spaces *between* rune positions (or
;; before or after them, at the ends), in [0..size]. The coordinate
;; before the first rune is 0, then after the first rune and
;; before the second is 1, and so on, until the coordinate after the
;; last rune is `size`.
;; 
;; We store the runes at integer indices in a flexarray
;; (starting at index 0) in two chunks which we call the head and the
;; tail, separated by the gap. The fields `head` and `gap` (and `tail`
;; if it weren't implicit) denote the lengths of these spans. `size`
;; denotes head+tail, i.e. the total length of text. The whole array
;; is of size size+gap, i.e. head+gap+tail.
;; 
;; The gap lets us insert or delete text by moving the gap instead
;; of the whole tail; if there's locality, this will be cheaper.


;; A coordinate that's never an actual text position. We'll use
;; -nowhere for "off the left end" and +nowhere for the right.
(let nowhere (expt 2 40))               ;XXX a dangerous pretense

;; Directions from a coordinate.
(let backward -1)
(let forward   1)

(to (flextext<-)

  (let t    (flexarray<-))
  (let head (box<- 0))
  (let gap  (box<- 0))
  (let size (box<- 0))

  ;; Return coordinate p clipped to the text's actual range.
  (to (clip p)
    (max 0 (min p size.^)))

  (to (clip-range p span)
    (let q (clip p))
    (let h (clip (+ q (max 0 span))))
    {range q (- h q)})

  ;; Pre: p is in [0..size).
  (to (get-rune-after p)
    (t (if (< p head.^) p (+ p gap.^))))

  ;; Return the `span` runes after `p0` as a text.
  (to (get p0 span0)
    (let {range p span} (clip-range p0 span0))
    (text<-list (each get-rune-after (p .span span))))

  ;; Return the position after the rune in the text that is in
  ;; rune-set and that comes up first in searching from p in
  ;; direction dir. If none, return nowhere or -nowhere.
  ;; XXX untested, probably broken
  (to (find-rune-set p dir rune-set)
    ((if (= dir forward)
         find-rune-set-forward
         find-rune-set-backward)
     (clip p)
     rune-set))

  (to (find-rune-set-forward p rune-set)
    (let H head.^)
    (begin searching ((p p))
      (if (< p H)
          (if (rune-set .maps? (t p))
              p.+
              (searching p.+))
          (do
            (let G gap.^)
            (let S size.^)
            (begin persevering ((p p))
              (if (< p S)
                  (if (rune-set .maps? (t (+ G p)))
                      p.+
                      (persevering p.+))
                  nowhere))))))

  (to (find-rune-set-backward p rune-set)
    (let H head.^)
    (let G gap.^)
    (begin searching ((p p))
      (if (< H p)
          (if (rune-set .maps? (t (+ G p.-)))
              p
              (searching p.-))
          (begin persevering ((p p))
            (if (< 0 p)
                (if (rune-set .maps? (t p.-))
                    p
                    (persevering p.-))
                (- nowhere))))))

  (to (grow n)
    (+ n (n .quotient 2)))

  ;; Replace the `span` runes after `p` by `replacement`.
  ;; TODO this code is hard to follow
  (to (replace p0 span0 replacement)
    (let {range p span} (clip-range p0 span0))
     
    ;; Make position p start the tail.
    (if (<= p head.^)
        (t .move! (+ gap.^ p)  t p                head.^)
        (t .move! head.^       t (+ gap.^ head.^) (+ gap.^ p)))
    (head .^= p)

    ;; Delete the next `span` runes.
    (gap .+= span)
    (size .-= span)

    ;; Grow the array so `replacement` fits in the gap.
    (let r-size replacement.count)
    (when (< gap.^ r-size)
      (let tail (- size.^ head.^)) ;XXX shouldn't this subtract the gap too?
      (let sz   (+ (grow (+ size.^ gap.^))   ;; TODO rename
                   r-size))
      (t .resize! sz)
      (t .move! (- sz tail) t (+ head.^ gap.^) (+ size.^ gap.^)) ;TODO isn't the last just t.count ?
      (gap .^= (- sz size.^)))

    ;; Insert `replacement`.
    (t .move! head.^ replacement 0 r-size)

    (head .+= r-size)
    (gap  .-= r-size)
    (size .+= r-size))

  (make flextext
    (to ~.clear!
      (head .^= 0)
      (gap  .^= 0)
      (size .^= 0))
    (to (~ .clip p)              (clip p))
    (to (~ .get p span)          (get p span))
    (to (~ .delete p span)       (replace p span "")) ;TODO rename these with !
    (to (~ .insert p text)       (replace p 0 text))
    (to (~ .replace p span text) (replace p span text))
    (to ~.count                  size.^)
    (to (~ .find-rune-set p dir rune-set)
      (find-rune-set p dir rune-set))
    ;; TODO: delegate to a text trait? but texts are immutable...
    (to ~.keys
      size.^.till)
    ))

(export
  backward
  forward
  nowhere
  flextext<-)
