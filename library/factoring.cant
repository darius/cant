;; List prime numbers
;; TODO add some way to reset/shrink the cache

;; Return a lazy list of all primes < limit.
(to (list-primes-till limit)
  (take-while (:: (< it limit)) the-primes))

;; Each odd prime found so far appears in a value of this map, in a
;; list keyed by the next candidate multiple of the prime to check.
;; E.g. 3 initially appears in (sieve 9) => '(3)
;;   (at 9, because 6 will get skipped because it's even).
;; Then after the sieve reaches 9, it will appear in (sieve 15) => '(3 5)
;;   (because 5 will have been inserted into the sieve earlier, also at 15).
(let sieve (!map<-))

(to (next-sieve! n p)
  (let next-key (+ n p p)) ;; Twice p because n and p are odd, and we only check odd numbers.
  (sieve .set! next-key (link p (sieve .get next-key '()))))

(next-sieve! 3 3)

;; Return a lazy list of the added primes.
(to (sieving n)
  (hm (when (let factors (sieve .get n))
        (sieve .delete! n)
        (for each! ((p factors))
          (next-sieve! n p))
        (sieving (+ n 2)))
      (else
        (next-sieve! n n)
        (link/lazier n (: (sieving (+ n 2)))))))

;; XXX used to be just (link 2 3 (sieving 5))... but some uses hit the
;; primitive list-ref since this started as a nonlazy list. Then list-ref barfed.
;; I knew that could happen but sort of hoped I wouldn't have to deal with it yet.
(let the-primes (link/lazier 2 (: (link/lazier 3 (: (sieving 5))))))

;; Return a list of the prime factors of a positive integer.
;; TODO return a lazy list?
;; TODO is this actually faster than naive-factor
(to (factor n)
  (surely (integer? n))
  (surely (< 0 n))
  (if (= n 1)
      '()
      (begin trying ((n n) (p the-primes.first) (primes the-primes.rest))
        (if (p .divides? n)
            (link p (if (= p n)
                        '()
                        (trying (n .quotient p) p primes)))
            (trying n primes.first primes.rest)))))

;; List n's divisors. Comes up a few times already in project-oiler, where the
;; naivest way to write it is too slow. I doubt it's really worth including here...
(to (list-divisors n)
  ;; (those (~ .divides? n) (1 .thru n))
  (hm (if (= n 1) '(1))
      (else (let pairs (run-encode (factor n)))
            (let powers (for each (((~ prime power) pairs))
                          (for each ((k (0 .thru power)))
                            (prime .** k))))
            (for each ((factors (grid* @powers)))
              (* @factors)))))

;; E.g. (a a b b b c) => ((~ a 2) (~ b 3) (~ c 1))
(to (run-encode xs)
  (surely xs.some?)
  (begin scanning ((n 1) (x xs.first) (xs xs.rest))
    (may xs
      (be '() `(,(~ x n)))
      (be `(,(= x) ,@rest) (scanning n.+ x rest))
      (else (link (~ x n) (scanning 1 xs.first xs.rest))))))


;; TODO reasonable efficiency
(to (prime? n)
  (surely (and (integer? n) (< 0 n)))
  (and (< 1 n)
       (= n ((factor n) .first))))



(to (test-me-till limit)

  ;; Like (factor n), but with simpler code just for testing.
  (to (naive-factor n)
    (surely (integer? n))
    (surely (< 0 n))
    (if (= n 1)
        '()
        (begin trying ((d 2) (n n))
          (if (d .divides? n)
              (link d (if (= d n) '() (trying d (n .quotient d))))
              (trying d.+ n)))))

  (let primes (~.range (list-primes-till limit)))
  (for each! ((n (1 .till limit)))
    (let factors (naive-factor n))
    (surely (= factors (factor n)))
    (hm (when (primes .maps? n)
          (surely (= `(,n) factors)))
        (else
          (surely (not factors.one?))
          (surely (= n (* @factors)))
          (surely (<= @factors))
          (each! (:: (surely (primes .maps? it))) factors)))))

;;(test-me-till 5000)
;;(out .print (as-list (list-primes-till 2000000)))


(export factor the-primes prime? list-primes-till list-divisors)
