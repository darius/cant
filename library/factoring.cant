;; List prime numbers
;; TODO add some way to reset/shrink the cache

;; (Will be extended. We need the last element to be odd, so we can
;; skip checking of even numbers.)
(let known-primes (flexarray<- 2 3))

;; Return a lazy list of all primes < limit.
(to (list-primes-till limit)
  (let n-known-initially known-primes.count)
  (begin listing-known ((i 0))
    (hm (if (= i n-known-initially) (venture-into-the-unknown limit))
        (do (let p (known-primes i)))
        (if (<= limit p) '())
        (else (link/lazy p (: (listing-known i.+)))))))

;; Each odd prime found so far appears in a value of this map, in a
;; list keyed by the next candidate multiple of the prime to check.
;; E.g. 3 initially appears in (sieve 9) => '(3)
;;   (at 9, because 6 will get skipped because it's even).
;; Then after the sieve reaches 9, it will appear in (sieve 15) => '(3 5)
;;   (because 5 will have been inserted into the sieve earlier, also at 15).
(let sieve (!map<-))

(to (next-sieve! n p)
  (let next-key (+ n p p)) ;; Twice p because n and p are odd, and we only check odd numbers.
  (sieve .set! next-key (link p (sieve .get next-key '()))))

(next-sieve! 3 3)

;; Add to known-primes from all candidates < limit; return a lazy list
;; of the added primes.
(to (venture-into-the-unknown limit)
  (begin trying ((n (+ known-primes.last 2)))
    (hm (when (<= limit n)
          '())
        (when (let factors (sieve .get n))
          (sieve .delete! n)
          (for each! ((p factors))
            (next-sieve! n p))
          (trying (+ n 2)))
        (else
          (known-primes .push! n)
          (next-sieve! n n)
          (link/lazy n (: (trying (+ n 2))))))))

;; Return a list of the prime factors of a positive integer.
;; TODO integrate with the above to speed this up
;; TODO return a lazy list?
(to (factor n)
  (surely (integer? n))
  (surely (< 0 n))
  (if (= n 1)
      '()
      (begin trying ((d 2) (n n))
        (if (d .divides? n)
            (link d (if (= d n) '() (trying d (n .quotient d))))
            (trying d.+ n)))))

;; TODO reasonable efficiency
(to (prime? n)
  (~.one? (factor n)))



(to (test-me-till limit)
  (let primes (~.range (list-primes-till limit)))
  (for each! ((n (1 .till limit)))
    (let factors (factor n))
    (hm (when (primes .maps? n)
          (surely (= `(,n) factors)))
        (else
          (surely (not factors.one?))
          (surely (= n (* @factors)))
          (surely (<= @factors))
          (each! (:: (surely (primes .maps? it))) factors)))))

;;(test-me-till 5000)
;;(out .print (as-list (list-primes-till 2000000)))


(export factor list-primes-till prime?)
