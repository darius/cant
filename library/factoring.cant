;; List prime numbers
;; TODO add some way to reset/shrink the cache

;; Return a lazy list of all primes < limit.
(to (list-primes-till limit)
  (take-while (:: (< it limit)) the-primes))

;; Each odd prime found so far appears in a value of this map, in a
;; list keyed by the next candidate multiple of the prime to check.
;; E.g. 3 initially appears in (sieve 9) => '(3)
;;   (at 9, because 6 will get skipped because it's even).
;; Then after the sieve reaches 9, it will appear in (sieve 15) => '(3 5)
;;   (because 5 will have been inserted into the sieve earlier, also at 15).
(let sieve (!map<-))

(to (next-sieve! n p)
  (let next-key (+ n p p)) ;; Twice p because n and p are odd, and we only check odd numbers.
  (sieve .set! next-key (link p (sieve .get next-key '()))))

(next-sieve! 3 3)

;; Return a lazy list of the added primes.
(to (sieving n)
  (hm (when (let factors (sieve .get n))
        (sieve .delete! n)
        (for each! ((p factors))
          (next-sieve! n p))
        (sieving (+ n 2)))
      (else
        (next-sieve! n n)
        (link/lazier n (: (sieving (+ n 2)))))))

(let the-primes (link 2 3 (sieving 5)))

;; Return a list of the prime factors of a positive integer.
;; TODO return a lazy list?
;; TODO is this actually faster than naive-factor
(to (factor n)
  (surely (integer? n))
  (surely (< 0 n))
  (if (= n 1)
      '()
      (begin trying ((n n) (p the-primes.first) (primes the-primes.rest))
        (if (p .divides? n)
            (link p (if (= p n)
                        '()
                        (trying (n .quotient p) p primes)))
            (trying n primes.first primes.rest)))))

;; TODO reasonable efficiency
(to (prime? n)
  (= n ((factor n) .first)))



(to (test-me-till limit)

  ;; Like (factor n), but with simpler code just for testing.
  (to (naive-factor n)
    (surely (integer? n))
    (surely (< 0 n))
    (if (= n 1)
        '()
        (begin trying ((d 2) (n n))
          (if (d .divides? n)
              (link d (if (= d n) '() (trying d (n .quotient d))))
              (trying d.+ n)))))

  (let primes (~.range (list-primes-till limit)))
  (for each! ((n (1 .till limit)))
    (let factors (naive-factor n))
    (surely (= factors (factor n)))
    (hm (when (primes .maps? n)
          (surely (= `(,n) factors)))
        (else
          (surely (not factors.one?))
          (surely (= n (* @factors)))
          (surely (<= @factors))
          (each! (:: (surely (primes .maps? it))) factors)))))

;;(test-me-till 5000)
;;(out .print (as-list (list-primes-till 2000000)))


(export factor the-primes prime? list-primes-till)
