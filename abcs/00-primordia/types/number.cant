(make-trait number-primitive me
  (to (~ .+ a)         (__+ me a))
  (to (~ .- a)         (__- me a))
  (to (~ .* a)         (__* me a))
  (to (~ .compare a)   (__number-compare me a))
  (to (~ .quotient b)  (__quotient me b))
  (to (~ .remainder b) (__remainder me b))
  (to (~ .modulo b)    (__modulo me b))
  (to (~ .*/mod m d)   (__*/mod me m d))
  (to (~ ./mod d)      (__*/mod me 1 d))
  (to (~ .<< b)        (__bit-<<  me b))
  (to (~ .>> b)        (__bit->>  me b))
  (to ~.not            (__bit-not me))
  (to (~ .and b)       (__bit-and me b))
  (to (~ .or b)        (__bit-or  me b))
  (to (~ .xor b)       (__bit-xor me b))
  (to (~ .** b)        (expt me b))
  (to ~.till           (interval<- 0 me))
  (to (~ .till @args)  (interval<- me @args))
  (to (~ .thru b @r)   (interval<- me b.+ @r))
  (to (~ .span n)      (interval<- me (+ me n)))
  (to ~.even?          (surely (integer? me)) (= 0 (me .modulo 2)))
  (to ~.odd?           (surely (integer? me)) (not= 0 (me .modulo 2)))
  (to (~ .divides? b)  (surely (integer? me)) (= 0 (b .modulo me)))
  (to ~.+              (__+ me 1))
  (to ~.-              (__- me 1))
  (to ~.sqrt           (sqrt me))
  (to ~.floor          (floor me))
  (to ~.ceiling        (ceiling me))
  (to ~.exact          (exact<-inexact me))
  (to ~.inexact        (inexact<-exact me))
  (to ~.magnitude      (abs me))
  (to ~.sign           (__number-compare me 0))
  (to ~.exp            (exp me))
  (to ~.ln             (log me))  ;; TODO better name?
  (to (~ .log base)    (log me base))
  (to ~.text           (text<-number me))
  (to ~.number         me)
  (to (~ .gcd b)       (gcd me b))
  (to ~.digits         (me .digits 10))
  (to (~ .digits base)  ;; N.B. little-endian
    (to (ok-radix? r) (and (integer? r) (< 1 r)))
    (hm (if (ok-radix? base)
            (begin converting ((n (abs me)))
              (hm (if (= n 0) '())
                  (do (let (~ q r) (n ./mod base)))
                  (else (link r (converting q))))))
        (if (and (list? base) (every ok-radix? base)) ;; Mixed-radix digits
            (begin converting ((n (abs me)) (moduli base))
              (hm (if (= n 0) '())
                  (if moduli.none? (list<- n))
                  (do (let (~ q r) (n ./mod moduli.first)))
                  (else (link r (converting q moduli.rest))))))
        (else (oops "Bad base" base))))
  ;; XXX sketchy support for 32-bit word ops:
  (to (~ .u+ a)        (__u+ me a))
  (to (~ .u- a)        (__u- me a))
  (to (~ .u* a)        (__u* me a))
  (to (~ .u/ a)        (__u/ me a))
  (to (~ .u>> a)       (__u>> me a))
  (to (~ .u<< a)       (__u<< me a))
  (to (~ .s+ a)        (__s+ me a))
  (to (~ .s* a)        (__s* me a))
  )
